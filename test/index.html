<html lang="en">
   <head>
      <meta charset="utf-8">

      <title>Shadow mapping</title>
      
      <link rel="stylesheet" href="http://benvanik.github.io/WebGL-Inspector/core/lib/gli.all.css">
      
      <!--
      <script src="http://benvanik.github.io/WebGL-Inspector/core/lib/gli.all.js"></script>
      <script src="http://benvanik.github.io/WebGL-Inspector/core/embed.js"></script>
      -->
   </head>

   <body style="margin:0;background:#222;position:relative;overflow:hidden">
      <canvas></canvas>

      <script class="shadow-mapper" type="x-shader/x-vertex">
         #version 100

         precision mediump float;

         attribute vec3 a_position;

         struct camera
         {
            mat4 projectionMatrix;
            mat4 modelViewMatrix;
            mat3 normalMatrix;
         };

         uniform camera u_lightCamera;
         
         void main()
         {
            gl_Position = u_lightCamera.projectionMatrix * u_lightCamera.modelViewMatrix * vec4(a_position, 1.0);
         }
      </script>

      <script class="shadow-mapper" type="x-shader/x-fragment">
         #version 100

         precision mediump float;
         
         void main(void)
         {
            gl_FragColor = vec4(gl_FragCoord.z, 0.0, 0.0, 0.0);
         }
      </script>

      <script class="renderer" type="x-shader/x-vertex">
         #version 100

         precision mediump float;
         
         const mat4 depthMatrix = mat4(0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.5, 0.5, 0.5, 1.0);

         attribute vec3 a_position;
         attribute vec2 a_uv;
         attribute vec3 a_normal;

         struct camera
         {
            mat4 projectionMatrix;
            mat4 modelViewMatrix;
            mat3 normalMatrix;
         };

         uniform camera u_camera;
         uniform camera u_lightCamera;

         varying vec4 v_position;
         varying vec4 v_shadow;
         varying vec2 v_uv;
         varying vec3 v_normal;

         void main()
         {
            vec4 position = vec4(a_position, 1.0);
         
            gl_Position = u_camera.projectionMatrix * u_camera.modelViewMatrix * position;

            v_position = position;
            v_shadow = depthMatrix * u_lightCamera.projectionMatrix * u_lightCamera.modelViewMatrix * position;
            v_uv = normalize(a_uv);
            v_normal = u_camera.normalMatrix * a_normal;
         }
      </script>

      <script class="renderer" type="x-shader/x-fragment">
         #version 100

         precision mediump float;

         struct material
         {
            int image;
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            int shading;
            int type;
         };

         struct light
         {
            vec3 ambient;
            vec3 diffuse;
            vec3 specular;
            vec3 attenuation;
            float intensity;
            vec3 location;
            int type;
         };

         uniform sampler2D u_image;
         uniform sampler2D u_shadowMap;
         uniform material u_material;
         uniform light u_light;

         varying vec4 v_position;
         varying vec4 v_shadow;
         varying vec2 v_uv;
         varying vec3 v_normal;

         vec3 pointLight()
         {
            vec3 normal = normalize(v_normal);
            vec3 direction = normalize(u_light.location - v_position.xyz);
            float weight = max(dot(direction, normal), 0.0);
            vec3 color = vec3(0.0);
            float range = length(direction);
            float attenuation = 1.0 / (u_light.attenuation.x + u_light.attenuation.y * range + u_light.attenuation.z * pow(range, 2.0));
            vec3 ambient = u_light.ambient * u_material.ambient;
            vec3 diffuse = u_light.intensity * u_light.diffuse * u_material.diffuse * weight;

            return (ambient + diffuse) * attenuation;
         }
         
         float visibility()
         {
            vec3 depth = v_shadow.xyz / v_shadow.w;
            float shadow = texture2D(u_shadowMap, depth.xy).r;
            float visible = 1.0;
            
            if (shadow < depth.z * 0.9999)
            {
               visible = 0.25;
            }
            
            return visible;
         }

         void main(void)
         {
            gl_FragColor = vec4(pointLight() * visibility(), 1.0);
         }
      </script>

      <script src="../dist/four.js"></script>

      <script>
         var cubeLoader = new Four.OBJMeshLoader({ path: 'meshes/cuboid.obj' });
         var monkeyLoader = new Four.OBJMeshLoader({ path: 'meshes/monkey.obj' });
         var planeLoader = new Four.OBJMeshLoader({ path: 'meshes/plane.obj' });

         setTimeout(function()
         {
            var shadowMapperProgram = new Four.Program({ selector: '.shadow-mapper' });
            var rendererProgram = new Four.Program({ selector: '.renderer' });
            var view = new Four.Framebuffer();
            var camera = new Four.PerspectiveCamera({
               direction: [0, 0, 0],
               location: [-15, 5, 15]
            });
            var lightCamera = new Four.PerspectiveCamera({
               path: 'lightCamera',
               width: Four.gl.canvas.width,
               height: Four.gl.canvas.height,
               direction: [-1, -1, -1],
               location: [5, 10, 5]
            });
            var scene = new Four.Scene();
            var light = new Four.PointLight({
               attenuation: [0.5, 0.5, 1],
               location: lightCamera.location
            });
            var cube = new Four.Mesh({
               buffers: new Four.VertexArrayObject({
                  attributes: ['vec3 position', 'vec3 normal']
               }),
               vertices: cubeLoader.vertices,
               normals: cubeLoader.normals,
               material: new Four.Material({
                  diffuse: 0xFFFFFF
               })
            });
            var monkey = new Four.Mesh({
               buffers: new Four.VertexArrayObject({
                  attributes: ['vec3 position', 'vec3 normal']
               }),
               vertices: monkeyLoader.vertices,
               normals: monkeyLoader.normals,
               material: new Four.Material({
                  diffuse: 0xFFFFFF
               })
            });
            var colorAttachment = new Four.DataTexture({
               width: Four.gl.canvas.width,
               height: Four.gl.canvas.height
            });
            var depthAttachment = new Four.DepthTexture({
               width: Four.gl.canvas.width,
               height: Four.gl.canvas.height
            });
            var plane = new Four.Mesh({
               buffers: new Four.VertexArrayObject({
                  attributes: ['vec3 position', 'vec2 uv', 'vec3 normal']
               }),
               vertices: planeLoader.vertices,
               uvs: planeLoader.uvs,
               normals: planeLoader.normals,
               material: new Four.Material({
                  diffuse: 0xFFFFFF
               })
            });
            var depthView = new Four.DepthFramebuffer({
               colorAttachment: colorAttachment,
               depthAttachment: depthAttachment
            });
            var shadowMap = new Four.Uniform({
               uniform: 'shadowMap',
               format: 'sampler'
            });
            
            scene.put(monkey);
            scene.put(plane);

            scene.use(shadowMapperProgram);
            light.bind(shadowMapperProgram);
            scene.render(depthView, lightCamera);
            
            scene.use(rendererProgram);
            light.bind(rendererProgram);
            lightCamera.bind(rendererProgram);
            scene.animate(view, camera,
               function()
               {
                  depthAttachment.bind();
                  shadowMap.set(rendererProgram, depthAttachment.unit);
               },
               function()
               {
                  depthAttachment.unbind();
               }
            );
         }, 2000);
      </script>
   </body>
</html>